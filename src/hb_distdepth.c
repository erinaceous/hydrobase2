/*   hb_distdepth.c
................................................................................
                              *  HydroBase2 *
................................................................................
                          
                    author:  Ruth Curry
                             Woods Hole Oceanographic Inst
                             July 2000 
................................................................................
/*  hb_distdepth computes depth, distance between points, and
 *  distance along track for a list of station locations.
 *
 * SFG added -v and -p options.  The -p is specifically for
 * high-resolution sections generated by gliders, Sept. 2014
 */

#include <stdio.h>
#include <stdlib.h>   /*sfg added to deal with exit warnings*/
#include <math.h>
#include "hb_paths.h"
#include "hb_memory.h"

#define    ABS(x)       (((x) < 0) ? -(x) : (x))
#define   NINT(x)       (((x) < 0) ? ((int)((x) - 0.5)) : ((int)((x) + 0.5)))

#define PI     3.141592654
#define   RADperDEG 0.017453292             /* pi/180 */
#define  EarthRadius  3437.747    /* in nm */
#define  NMperKM  .539593
#define KMperNM   1.853248652
#define MperNM   1853.248652
/* global variables for topography grid*/
	
short **ztopo;
int 	 depth_is_neg;   
int     ncols, nrows;
double   xmin, xmax, ymin, ymax, delta_x, delta_y;
float  *topo_lat, *topo_lon;
int lon0to360;

/* prototypes for locally defined functions */

void print_usage(char *);
int vector(double, double, double, double, double *, double *);
void output_pos(FILE *, double, double, int, int, double, double, double, int, int);
short **get_topo(FILE *);
double find_nearest_topo_val(double, double, short **);
 
main (int argc, char **argv)
{
int i;
int stano, sflag, lonfirst;
int error, kilo, mflag, vflag, pflag;
int hdg;
double lat, lon, phi, cumdist, depth;
double start_lat, start_lon, temp;
double prev_lat, prev_lon, dist;
double dx, dy;
char *st;
FILE  *outfile, *infile, *topofile;
   

/* are there command line arguments? */

   if (argc < 2) {
      print_usage(argv[0]);
      exit(1);
   }
  
/*  set these default values */
 
    outfile = stdout;
    infile = stdin;
    prev_lat = prev_lon = -999.0;
    error = 0;
     stano= 1;
    kilo = 0;
    mflag = sflag = vflag = pflag = 0;
    lonfirst = 0;
    
/* define topography grid */
    depth_is_neg = 1;
    xmin = 0;
    xmax = 360;
    ymin = -90.0;
    ymax = 90.0;
    delta_x = delta_y = 0.1;
    lon0to360 = 0;
     
for (i = 1; !error && i < argc; i++) {
   if (argv[i][0] == '-') {
     switch (argv[i][1]) {
        case 'I':
	   infile = fopen(&argv[i][2], "r");
	   if (infile == NULL) {
	      fprintf(stderr,"Unable to open %s for input.\n", &argv[i][2]);
	      exit(1);
	   }
          break;
        case 'K':
          kilo = 1;
          break;
        case 'p':
	  pflag = 1;
	  break;
        case 'M':
          mflag = 1;
          break;
        case 'v':
	  vflag = 1;
	  break;
	case 'L':
	   if (argv[i][2] == '+')
	       lon0to360 = 1;
	   else {
	      if (argv[i][2] == '-')
	         lon0to360 = 0;
	      else 
	         error = 1;
	   }
	   break;
        case 'S':
          sflag = 1;
          if (argv[i][2] != '\0') {
             error = sscanf(&argv[i][2],"%d", &stano) == 1 ? 0 : 1;
          }
          break;
        case ':':  
	  lonfirst = 1;
	  break;
        case 'h':  
	  print_usage(argv[0]);
	  exit(0);

       default:
          error = 1;
          break;
     }  /* end switch */
   }
   else 
      error = 1;
      
} /* end for */
   
if (error) {
   fprintf(stderr,"\nError parsing command line");
   fprintf(stderr,"\n in particular: %s\n", argv[i]);
   exit(1);
} 

if ( pflag & kilo ) {
   fprintf(stderr,"\nError: cannot have both -K and -p!");
   fprintf(stderr,"\nYou must pick either kilometers or meters.");
   exit(1);
} 
/* read in topography file ... */

 if ( vflag ) {
     fprintf(stderr,"\nOpening topography file...");
 }
   topofile = fopen(BATHPATH,"r");
   if (topofile == NULL) {
          fprintf(stderr,"\nUnable to open default topography file\n", BATHPATH);
          exit(1);
   }
    ztopo = get_topo(topofile);
    fclose(topofile);
    

   
/*  Read first location and output it...*/

   if (lonfirst)
      fscanf(infile, "%lf %lf", &start_lon, &start_lat);
   else
      fscanf(infile, "%lf %lf", &start_lat, &start_lon);
      
   phi = 0;
   dist = 0.0;
   cumdist = 0.0;
   hdg = 0;
   
   depth = find_nearest_topo_val(start_lat, start_lon, ztopo);
   /* Add a # sign to show first line is a header line. */
   fprintf(outfile,"#");
   if (sflag)
       fprintf(outfile, " Sta # "); 
   fprintf(outfile, "  Lat           Lon       Hdg  Depth(m)   Distance   Cum Dist ");
   if (kilo) {
      fprintf(outfile, "  (in km) \n");
   } else {
     if (pflag) {
       fprintf(outfile, "  (in m) \n");
     } else {
      fprintf(outfile, "  (in nm)  \n");
     }
   }
   
   output_pos(outfile, start_lat, start_lon, stano, hdg, depth, dist, cumdist, sflag, mflag);
  

/* loop for each position */

   prev_lat = start_lat;
   prev_lon = start_lon;
   
   while (fscanf(infile, "%lf %lf", &start_lat, &start_lon) == 2) {
   
       if (lonfirst) {
          temp = start_lat;
	  start_lat = start_lon;
	  start_lon = temp;
       }
       ++stano;
       hdg = vector(prev_lat, prev_lon, start_lat, start_lon, &phi, &dist);

       if (kilo) {
           dist *= KMperNM;
       }
       if (pflag) {
	   dist *= MperNM;
       }

       cumdist += dist;
       depth = find_nearest_topo_val(start_lat, start_lon, ztopo);
       output_pos(outfile, start_lat, start_lon, stano, hdg, depth, dist, cumdist, sflag, mflag);
      
        prev_lat = start_lat;
        prev_lon = start_lon;
      
   }
   if ( vflag ) {
     fprintf(stderr,"\nEnd of hb_distdepth.\n"); 
   }
   exit(0);
} /* end main */

/****************************************************************************/

void print_usage(char *program)
{
   fprintf(stderr,"\nDetermines distance between a list of locations and depth at each location");       
   fprintf(stderr,"\nOutputs  station # (optional), lat, lon, hdg, depth, distance, cumdist"); 
   fprintf(stderr,"\n\nUsage:  %s [-I{input_position_file>]   [-K] [-L<+/->]  [-M] [-S<start_sta>] [-h]", program);
   fprintf(stderr,"\n\n  OPTIONS:");
   fprintf(stderr,"\n-I :  file containing input positions (lat/lon).");
   fprintf(stderr,"\n-K :  output distance in km (default is nm).");
   fprintf(stderr,"\n-L :  output West longitude either positive [-L+] or negative [-L-].");
   fprintf(stderr,"\n         default : W longitude is negative [-L-]");
   fprintf(stderr,"\n-M :  output positions in deg/mins (default is decimal degrees).");
   fprintf(stderr,"\n-S :  output station # in 1st column sequentially starting with");
   fprintf(stderr,"\n         station specified.  ex:  -S1");
   fprintf(stderr,"\n-: :  input positions are lon lat.  default is lat lon");
   fprintf(stderr,"\n-v :  verbose; progress reports written to stderr.");
   fprintf(stderr,"\n-p :  precise; output in metres (rather than km or nm).");
   fprintf(stderr,"\n-h help...... prints this message. \n");
   fprintf(stderr,"\n\n");  
   return;
}

/****************************************************************************/
void output_pos(FILE *ofile, double  lat, double lon, int sta, int hdg, double depth, double distance, double distsum, int sflag, int mflag)
{
   int deg;
   double mins;

   if (sflag) 
     fprintf(ofile,"%5d ", sta);
     
   if (lon0to360) {
      if (lon < 0.0)
         lon += 360.0;
      
   }
   else {
      if (lon > 180.)
          lon -= 360.0;
   }
  
   if (mflag) {
      deg =  (int)(fabs(lat) + .0001);
      mins = 60 * (fabs(lat) - (double) deg);
      fprintf(ofile,"%4d %4.1lf ",deg, mins);
      if (lat < 0)
           fprintf(ofile,"S ");
      else
         fprintf(ofile,"N ");
      
      deg =  (int)(fabs(lon) + .0001);
      mins = 60 * (fabs(lon) - (double) deg);
      fprintf(ofile,"%4d %4.1lf ",deg, mins);
      if (lon < 0)
           fprintf(ofile,"W ");
      else
         fprintf(ofile,"E ");
   }
   else {
      fprintf(ofile,"%12.3lf %12.3lf ", lat, lon);
   }
   
    fprintf(ofile,"%5d %8.0lf  %10.2lf %12.2lf", hdg, depth, distance, distsum);
     
  
   fprintf(ofile,"\n");
   return;  
} /* end output_pos() */
/****************************************************************************/
int vector(double lat1, double lon1, double lat2, double lon2, double *phi_addr, double *dist_addr)
  /* Returns the direction from point1->point2 in degrees from north.
     The arctan of this direction in radians  (domain is -pi/2 to +pi/2)
     is returned at phi_addr. The distance in nautical miles is returned
     at dist_addr */
{
   double dx, dy;
   
   dx = (lon2 - lon1)* RADperDEG * cos(RADperDEG*.5 *(lat1+lat2)) * EarthRadius ;
   dy = (lat2 - lat1) * RADperDEG * EarthRadius;
   
   if (dy == 0) {  /* course is zonal */
     *dist_addr = dx;
     if (dx < 0) {
       *phi_addr = -PI/2;
       *dist_addr = -dx;
       return(270);
     }
     *phi_addr = PI /2;
     return (90);
   }
   
   if (dx == 0.) {   /* meridional */
     *dist_addr = dy;
     *phi_addr = 0.0;
     if (dy < 0) {
       *dist_addr = -dy;
       return(180);
     }
     return(0);
   }

   *phi_addr = atan(dx/dy);
   *dist_addr = sqrt(dx*dx + dy*dy);
   
   if (*phi_addr > 0) {   
      if (dx > 0)
         return (NINT(*phi_addr / RADperDEG));   /* 0 -> 90 */
      
      return (180 + NINT(*phi_addr / RADperDEG)); /* 180 -> 270 */
   }
   
   if (dx > 0) 
     return (180 + NINT(*phi_addr / RADperDEG));  /* 90 -> 180 */
     
   return (360 + NINT(*phi_addr / RADperDEG));  /* 270 -> 360 */

}  /* end vector() */
      
/****************************************************************************/
 /****************************************************************************/
short **get_topo(FILE *fptr)
   /* allocates memory and reads in topography values.  Returns a pointer to
      the start of the memory block. An error causes an error message to be
      printed and an exit.   */
{

   int row, n;
   short **z;
   
   /* Set some globally defined variables */
   
   nrows = (int)NINT((ymax - ymin) / delta_y) + 1;
   ncols = (int)NINT((xmax - xmin) / delta_x) + 1;
   
   topo_lat = (float *) malloc(nrows * sizeof(float));
   topo_lon = (float *) malloc(ncols * sizeof(float));
   
   for (n = 0; n < nrows; ++n) {
     topo_lat[n] = (float) ((double) n * delta_y + ymin);
   }
   
   for (n = 0; n < ncols; ++n) {
     topo_lon[n] = (float) ((double) n * delta_x + xmin);
   }
   
   z = (short **) malloc(nrows * sizeof(short *));
   if (z == NULL) {
      fprintf(stderr,"\nError allocating memory.\n");
      exit(1);
   }
   
   for (row = 0; row < nrows; ++row) {
     z[row] = (short *) malloc(ncols * sizeof(short));
     if (z[row] == NULL) {
         fprintf(stderr,"\nError allocating memory.\n");
         exit(1);
      }
   }
   
   /*fprintf(stderr,"\nReading in topography values ");
    */
   
   for (row = 0; row < nrows; ++row) {
     n = fread((short *)z[row], sizeof(short), ncols, fptr);
     if (n != ncols) {
         fprintf(stderr,"\nError reading the topofile at row %d\n", row);
         exit(1);
     }
     /* signal progress */
     /*if ((row % 10) == 0)   
       fprintf(stderr,".");
      */
   }
   
   /*fprintf(stderr,"\nFinished reading topofile.\n");*/
   
   return(z);

} /* end get_topo() */
/****************************************************************************/
/****************************************************************************/

double find_nearest_topo_val(double lat, double lon, short **topo)
   /* interpolates nearest values in topo matrix and returns bottom
      depth for lat/lon specified.  Depth returned is positive below 
      sea level/ negative above. */
      
{
  int row, col, row2, col2;
  short z;
  double zn, zs;

/* convert longitudes to 0 - 360 range */
  
  if (lon < 0.0 ) {
    lon += 360.0;
  }
  
  row = (int) ((lat - ymin) / delta_y);
  col = (int) ((lon - xmin) / delta_x);
  
  /* row and row+1 should bracket the lat; col and col+1 the lon */
  
  if ((row < 0) || (row >= nrows)) {
    fprintf(stderr,"\nRow (%d) computed for latitude (%7.3f) does not exist in topo file.\n", row, lat);
    exit(1);
  }
  
   if ((col < 0) || (col >= ncols)) {
    fprintf(stderr,"\nColumn (%d) computed for longitude (%8.3f) does not exist in topo file.\n", col, lon);
    exit(1);
  }
  
  col2 = col + 1;
  row2 = row + 1;
  
  if (col2 >= ncols) {
     fprintf(stderr,"\nDid not expect to have longitude right on xmax -- report bug 1 in find_nearest_topo_val()\n");
     exit(1);
  }
  
  zs = (double)topo[row][col] + (double)(topo[row][col2] - topo[row][col]) * (lon - topo_lon[col]) / (double)(topo_lon[col2] - topo_lon[col]);
  
  if (row2 >= nrows) {  /* Must be at the north pole */
      z = (short) zs;
      if (depth_is_neg)
         z = -z;
      return(z);
   }
      
  zn = topo[row2][col] + (short) ((double)(topo[row2][col2] - topo[row2][col]) * (lon - (double)topo_lon[col]) / (double)(topo_lon[col2] - topo_lon[col]) );
  
  z = (short) (zs + (zn - zs) * (lat - (double)topo_lat[row]) / (double)(topo_lat[row2] - topo_lat[row]));
  
  if (depth_is_neg)
    z = -z;
      
  return( (double) z);
 

}  /* end find_nearest_topo_val() */

